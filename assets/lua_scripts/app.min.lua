require("graphics.min")local a=require('data.min')local b=require('rich_text.min')local c=require('camera.min')local d=require('code.min')SCRIPT_VERSION="v1.0.8"local e=Graphics.new()EXPOSURE_NUMBER=10;local f=0;local g=0;local h=false;local i=false;local j=false;local k=0;local l=false;local m=nil;local n=0;local o=true;MESSAGE_RESPONSE_FLAG=0x20;HOLD_RESPONSE_FLAG=0x23;DATA_MSG=0x22;TAP_SUBS_FLAG=0x10;CHECK_FW_VERSION_FLAG=0x16;CHECK_SCRIPT_VERSION_FLAG=0x17;LISTENING_FLAG=0x11;STOP_LISTENING_FLAG=0x12;STOP_TAP_FLAG=0x13;LOOK_AHEAD_FLAG=0x14;AUDIO_DATA_NON_FINAL_MSG=0x05;AUDIO_DATA_FINAL_MSG=0x06;local function p(a)local q=frame.time.utc()+2;while frame.time.utc()<q do if pcall(frame.bluetooth.send,a)then return end end end;function run_auto_exp(r,s)local t=frame.time.utc()if r==0 or t-r>s then c.run_auto_exposure()n=n+1;return t else return r end end;local function u(v)local w=frame.imu.direction()if not(w['roll']>-20 and w['roll']<20 and w['pitch']>-60 and w['pitch']<40)then if v then e:clear()e:append_text("look ahead","\u{F0000}")end else print("LOOKING AHEAD")o=true end end;local function x()pcall(frame.bluetooth.send,string.char(TAP_SUBS_FLAG))end;a.parsers[MESSAGE_RESPONSE_FLAG]=b.parse_rich_text;a.parsers[DATA_MSG]=d.parse_code;a.parsers[LISTENING_FLAG]=c.parse_capture_settings;local function y()if a.app_data[DATA_MSG]~=nil then local z=a.app_data[DATA_MSG].value;if z==TAP_SUBS_FLAG then frame.imu.tap_callback(x)elseif z==STOP_TAP_FLAG then frame.imu.tap_callback(nil)elseif z==STOP_LISTENING_FLAG then frame.microphone.stop()elseif z==CHECK_FW_VERSION_FLAG then p(string.char(CHECK_FW_VERSION_FLAG)..frame.FIRMWARE_VERSION)elseif z==CHECK_SCRIPT_VERSION_FLAG then p(string.char(CHECK_SCRIPT_VERSION_FLAG)..SCRIPT_VERSION)elseif z==LOOK_AHEAD_FLAG then o=false;u(true)elseif z==HOLD_RESPONSE_FLAG then print("HOLD FOR RESPONSE")end;a.app_data[DATA_MSG]=nil end;if a.app_data[LISTENING_FLAG]~=nil and o then print("LISTENING")h=true;n=0;l=false;m=a.app_data[LISTENING_FLAG]frame.microphone.start{}a.app_data[LISTENING_FLAG]=nil end;if a.app_data[MESSAGE_RESPONSE_FLAG]~=nil and a.app_data[MESSAGE_RESPONSE_FLAG].string~=nil and o then e:clear()e:append_text(a.app_data[MESSAGE_RESPONSE_FLAG].string,a.app_data[MESSAGE_RESPONSE_FLAG].emoji)a.app_data[MESSAGE_RESPONSE_FLAG]=nil end end;local function A()local B=frame.bluetooth.max_length()local C=math.floor((B-1)/2)*2;local D=nil;for E=1,20 do D=frame.microphone.read(C)if D==nil then print("STOPPED LISTENING")pcall(p,string.char(AUDIO_DATA_FINAL_MSG))h=false;break elseif D~=''then pcall(p,string.char(AUDIO_DATA_NON_FINAL_MSG)..D)else break end end end;e:append_text("","\u{F000D}")collectgarbage("collect")while true do local F=a.process_raw_items()if F>0 then i=false;j=false;rc,err=pcall(y)if not rc then print(err)end;g=frame.time.utc()end;if not o then u(false)end;if frame.bluetooth.is_connected()==false and not j then j=true;e:clear()e:append_text("","\u{F000D}")end;if frame.time.utc()-g>15 and not i and not h then i=true;e:clear()e:append_text("","\u{F0008}")end;if frame.time.utc()-f>0.07 then e:print()f=frame.time.utc()end;if frame.time.utc()-g>18 and i then frame.microphone.stop()frame.display.text(' ',1,1)frame.display.show()frame.sleep(0.05)frame.sleep()end;if h then A()if not l and(n>10 or not h)then print("CAPTURE")c.capture_and_send(m)l=true;m=nil end end;k=run_auto_exp(k,0.1)frame.sleep(0.001)collectgarbage("collect")end